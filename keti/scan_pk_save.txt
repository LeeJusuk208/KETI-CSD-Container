if(snippet_->total_primary_size != 0){
        char total_key_value[row_size+snippet_->total_primary_size];
        int primary_key_offset = 0;

        std::list<PrimaryKey>::iterator piter;
        for(piter = snippet_->primary_key_list.begin(); piter != snippet_->primary_key_list.end(); piter++){
            // std::cout << "primary key name: " << (*piter).key_name;
            // std::cout << " | primary key size: " << (*piter).key_length;
            // std::cout << " | primary key type: " << (*piter).key_type << std::endl;

            int key_length = (*piter).key_length;
            int key_type = (*piter).key_type;

            if(key_type == 8 || key_type == 4){//big int or int
                char primary_key[key_length];

                for(int i = 0; i < key_length; i++){
                  // printf("%02X ",(u_char)ikey_data[i+indexnum_size+primary_key_offset]);
                  primary_key[i] = ikey_data[i+indexnum_size+primary_key_offset];
                }//primary_key[80 00 00 00 00 00 00 01 ]

                std::bitset<8> bs(primary_key[0]);//8 하드코딩!!!!!!!!!!!!!!!!!!!!!!!
                // std::cout << "bs:" << bs << std::endl; // int_binary:10000000
                bs ^= 1 << (key_length-1);
                // std::cout << "bs:" << bs << std::endl; // int_binary:00000000
                primary_key[0] =  (int)(bs.to_ulong());

                // printf("primary_key[0]: %02X ",primary_key[0]); //primary_key[0]: 00
                // std::cout << " primary_key["; // primary_key[00 00 00 00 00 00 00 01 ]
                // for(int i = 0; i < key_length; i++){
                //     printf("%02X ",(u_char)primary_key[i]);
                // }
                // std::cout << "]\n";

                // long my_value = *((long *)primary_key);
                // std::cout << "my_value " << my_value << std::endl;;

                char reversed_primary_key[key_length];
                for(int i = 0; i < key_length; i++){
                    reversed_primary_key[i] = primary_key[key_length-i-1];
                    // printf("(%02X %02X)",(u_char)reversed_primary_key[i], (u_char)primary_key[key_length-i-1]);
                }
                // std::cout << std::endl;

                // my_value = *((long *)reversed_primary_key);
                // std::cout << "my_value " << my_value << std::endl;;

                memcpy(total_key_value+primary_key_offset, reversed_primary_key, key_length);
                // std::cout << " total data[";
                // for(int i = 0; i < key_length+primary_key_offset; i++){
                //     printf("%02X",(u_char)total_key_value[i]);
                // }
                // std::cout << "]\n";

                primary_key_offset += key_length;
            }else if(key_type == 14){
              // 다른 타입일 경우
            } 

          } 
          memcpy(total_key_value+snippet_->total_primary_size, row_data, row_size);

          // std::cout << "total_key_value[";
          // for(int i = 0; i < row_size+snippet_.total_primary_size; i++){
          //     printf("%02X",(u_char)total_key_value[i]);
          // }
          // std::cout << "]\n";

          memcpy(scan_result->data+scan_result->length, total_key_value, row_size+snippet_->total_primary_size);
          scan_result->length += row_size+snippet_->total_primary_size;
          scan_result->row_count++;
          // std::cout << "new data[";
          // for(int i = 0; i < scan_result.length; i++){
          //     printf("%02X",(u_char)scan_result.data[i]);
          // }
          // std::cout << "]\n";
      }else{
          memcpy(scan_result->data+scan_result->length, row_data, row_size);
          scan_result->length += row_size;
          scan_result->row_count++;
      }